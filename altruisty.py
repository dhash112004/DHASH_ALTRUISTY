# -*- coding: utf-8 -*-
"""Altruisty.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XoGEmc6MCwZzAsUyNM-0ilNRY-Xt6rkc

**PROBLEM STATEMENT 1**
"""

#PROBLEM STATEMENT 1
def findTwoNumbers(arr):
    xor_all = 0

    # Step 1: XOR all the numbers together
    for num in arr:
        xor_all ^= num

    # Step 2: Find the rightmost set bit (where x and y differ)
    rightmost_set_bit = xor_all & -xor_all

    num1, num2 = 0, 0

    # Step 3: Divide numbers into two groups and XOR each group
    for num in arr:
        if num & rightmost_set_bit:
            num1 ^= num
        else:
            num2 ^= num

    # Step 4: Return the two numbers in increasing order
    return sorted([num1, num2])

# Get user input
N = int(input("N = "))  # Read the value of N
arr = list(map(int, input(f"arr[]=").split()))  # Read the array

# Call the function and print the result
result = findTwoNumbers(arr)
print(result)

"""**PROBLEM STATEMENT 2**"""

#PROBLEM STATEMENT 2
def wordBreak(s, dictionary):
    n = len(s)
    dp = [False] * (n + 1)  # DP table
    dp[0] = True  # Empty string is always breakable

    # Iterate over the string
    for i in range(1, n + 1):
        for j in range(i):
            # If substring s[j:i] is in the dictionary and dp[j] is True
            if dp[j] and s[j:i] in dictionary:
                dp[i] = True
                break  # No need to check further if we found a valid break

    # Return 1 if the whole string can be segmented, otherwise 0
    return 1 if dp[n] else 0

# Get input from the user
n = int(input("Enter the number of words in the dictionary: "))
dictionary = set(input(f"Enter {n} words separated by space: ").split())
s = input("Enter the string to be segmented: ")

# Call the function and print the result
result = wordBreak(s, dictionary)
print(result)  # Output 1 if possible to segment, else 0

"""**PROBLEM STATEMENT 3**"""

#PROBLEM STATEMENT 3
from collections import deque

def generateSteppingNumbers(n, m):
    stepping_numbers = set()

    # Start BFS from single digit numbers
    queue = deque(range(10))  # Single digit numbers from 0 to 9

    while queue:
        num = queue.popleft()

        if num >= n and num <= m:
            stepping_numbers.add(num)

        # Generate next numbers if they are within the range
        if num == 0 or num > m:
            continue

        last_digit = num % 10

        # Generate the next possible stepping numbers
        next_num1 = num * 10 + (last_digit - 1)
        next_num2 = num * 10 + (last_digit + 1)

        if next_num1 >= 0 and next_num1 <= m:
            queue.append(next_num1)
        if next_num2 <= m:
            queue.append(next_num2)

    return sorted(stepping_numbers)

# Input
n, m = map(int, input().split())

# Find and print stepping numbers
result = generateSteppingNumbers(n, m)
print(" ".join(map(str, result)))

"""**PROBLEM STATEMENT 4**"""

#PROBLEM STATEMENT 4
def minimizePrice(ticket_price, k):
    stack = []

    # Traverse each digit in the ticket price
    for digit in ticket_price:
        # Remove digits from the stack if the current digit is smaller and we still have turns left
        while k > 0 and stack and stack[-1] > digit:
            stack.pop()
            k -= 1
        stack.append(digit)

    # If we still have turns left, remove from the end of the stack
    while k > 0:
        stack.pop()
        k -= 1

    # Convert the stack to a string and remove leading zeros
    minimized_price = ''.join(stack).lstrip('0')

    # If the result is empty, it means we removed all digits; return '0' as per the problem constraints
    if not minimized_price:
        return '0'

    return minimized_price

# Input reading
ticket_price = input().strip()
k = int(input().strip())

# Calculate and print the minimized price
result = minimizePrice(ticket_price, k)
print(result)

"""**PROBLEM STATEMENT 5**"""

#PROBLEM STATEMENT 5
def getMaxToys(prices, money):
    n = len(prices)
    max_toys = 0
    current_sum = 0
    start = 0

    for end in range(n):
        current_sum += prices[end]

        while current_sum > money:
            current_sum -= prices[start]
            start += 1

        max_toys = max(max_toys, end - start + 1)

    return max_toys

# Input reading
n = int(input().strip())
prices = list(map(int, input().strip().split()))
money = int(input().strip())

# Calculate and print the maximum number of toys
result = getMaxToys(prices, money)
print(result)